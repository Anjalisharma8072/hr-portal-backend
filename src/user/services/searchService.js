const GeneratedOffer = require('../model/generatedOffer');
const Template = require('../model/template');
const Company = require('../model/company');

/**
 * Advanced Search and Filtering Service
 * Provides comprehensive search, filtering, and sorting capabilities for offers
 */
class SearchService {
  constructor() {
    this.defaultSort = { createdAt: -1 };
    this.defaultLimit = 20;
    this.maxLimit = 100;
  }

  /**
   * Advanced search for offers
   */
  async searchOffers(searchParams, userId, organisationId) {
    try {
      console.log('üîç [SearchService] Advanced search request:', searchParams);

      const {
        query = '',
        filters = {},
        sort = {},
        pagination = {},
        includeArchived = false
      } = searchParams;

      // Build search query
      const searchQuery = this.buildSearchQuery(query, filters, organisationId, includeArchived);

      // Build sort options
      const sortOptions = this.buildSortOptions(sort);

      // Build pagination options
      const paginationOptions = this.buildPaginationOptions(pagination);

      // Execute search
      const [offers, total] = await Promise.all([
        GeneratedOffer.find(searchQuery)
          .sort(sortOptions)
          .skip(paginationOptions.skip)
          .limit(paginationOptions.limit)
          .populate('templateId', 'name category industry')
          .populate('companyData.companyId', 'companyName industry companyType')
          .populate('metadata.generatedBy', 'email name')
          .lean(),
        GeneratedOffer.countDocuments(searchQuery)
      ]);

      // Calculate pagination info
      const totalPages = Math.ceil(total / paginationOptions.limit);
      const hasNextPage = paginationOptions.page < totalPages;
      const hasPrevPage = paginationOptions.page > 1;

      console.log('‚úÖ [SearchService] Search completed:', {
        results: offers.length,
        total,
        page: paginationOptions.page,
        totalPages
      });

      return {
        offers: this.formatSearchResults(offers),
        pagination: {
          currentPage: paginationOptions.page,
          totalPages,
          totalItems: total,
          itemsPerPage: paginationOptions.limit,
          hasNextPage,
          hasPrevPage
        },
        filters: this.getAppliedFilters(filters),
        sort: sortOptions
      };

    } catch (error) {
      console.error('‚ùå [SearchService] Search error:', error);
      throw error;
    }
  }

  /**
   * Build search query based on parameters
   */
  buildSearchQuery(query, filters, organisationId, includeArchived) {
    const searchQuery = {
      'metadata.organisation': organisationId
    };

    // Text search across multiple fields
    if (query && query.trim()) {
      const searchRegex = { $regex: query.trim(), $options: 'i' };
      searchQuery.$or = [
        { 'candidateData.candidate_name': searchRegex },
        { 'candidateData.candidate_email': searchRegex },
        { 'candidateData.designation': searchRegex },
        { 'candidateData.department': searchRegex },
        { 'candidateData.work_location': searchRegex }
      ];
    }

    // Status filter
    if (filters.status && filters.status !== 'all') {
      searchQuery.status = filters.status;
    }

    // Date range filters
    if (filters.dateRange) {
      const dateQuery = {};
      
      if (filters.dateRange.startDate) {
        dateQuery.$gte = new Date(filters.dateRange.startDate);
      }
      
      if (filters.dateRange.endDate) {
        dateQuery.$lte = new Date(filters.dateRange.endDate);
      }
      
      if (Object.keys(dateQuery).length > 0) {
        searchQuery.createdAt = dateQuery;
      }
    }

    // Salary range filters
    if (filters.salaryRange) {
      const salaryQuery = {};
      
      if (filters.salaryRange.min) {
        salaryQuery.$gte = parseFloat(filters.salaryRange.min);
      }
      
      if (filters.salaryRange.max) {
        salaryQuery.$lte = parseFloat(filters.salaryRange.max);
      }
      
      if (Object.keys(salaryQuery).length > 0) {
        searchQuery['candidateData.total_ctc'] = salaryQuery;
      }
    }

    // Industry filter
    if (filters.industry && filters.industry !== 'all') {
      searchQuery['companyData.industry'] = filters.industry;
    }

    // Company type filter
    if (filters.companyType && filters.companyType !== 'all') {
      searchQuery['companyData.companyType'] = filters.companyType;
    }

    // Department filter
    if (filters.department && filters.department !== 'all') {
      searchQuery['candidateData.department'] = filters.department;
    }

    // Template filter
    if (filters.template && filters.template !== 'all') {
      searchQuery.templateId = filters.template;
    }

    // Generated by filter
    if (filters.generatedBy && filters.generatedBy !== 'all') {
      searchQuery['metadata.generatedBy'] = filters.generatedBy;
    }

    // Location filter
    if (filters.location && filters.location !== 'all') {
      searchQuery['candidateData.work_location'] = filters.location;
    }

    // Experience level filter
    if (filters.experienceLevel && filters.experienceLevel !== 'all') {
      searchQuery['candidateData.experience_years'] = this.getExperienceRange(filters.experienceLevel);
    }

    // Compliance filter
    if (filters.compliance && filters.compliance !== 'all') {
      searchQuery['compliance.isCompliant'] = filters.compliance === 'compliant';
    }

    // Archive filter
    if (!includeArchived) {
      searchQuery.isArchived = { $ne: true };
    }

    // Priority filter
    if (filters.priority && filters.priority !== 'all') {
      searchQuery['metadata.priority'] = filters.priority;
    }

    // Tags filter
    if (filters.tags && filters.tags.length > 0) {
      searchQuery['metadata.tags'] = { $in: filters.tags };
    }

    return searchQuery;
  }

  /**
   * Build sort options
   */
  buildSortOptions(sort) {
    const sortOptions = { ...this.defaultSort };

    if (sort.field && sort.order) {
      const order = sort.order === 'desc' ? -1 : 1;
      sortOptions[sort.field] = order;
      
      // Remove default sort if custom sort is applied
      if (sort.field !== 'createdAt') {
        delete sortOptions.createdAt;
      }
    }

    return sortOptions;
  }

  /**
   * Build pagination options
   */
  buildPaginationOptions(pagination) {
    const page = Math.max(1, parseInt(pagination.page) || 1);
    const limit = Math.min(
      this.maxLimit,
      Math.max(1, parseInt(pagination.limit) || this.defaultLimit)
    );
    const skip = (page - 1) * limit;

    return { page, limit, skip };
  }

  /**
   * Get experience range for filtering
   */
  getExperienceRange(level) {
    const ranges = {
      'entry': { $lt: 2 },
      'junior': { $gte: 2, $lt: 5 },
      'mid': { $gte: 5, $lt: 8 },
      'senior': { $gte: 8, $lt: 12 },
      'expert': { $gte: 12 }
    };

    return ranges[level] || {};
  }

  /**
   * Format search results
   */
  formatSearchResults(offers) {
    return offers.map(offer => ({
      id: offer._id,
      candidateName: offer.candidateData.candidate_name,
      candidateEmail: offer.candidateData.candidate_email,
      designation: offer.candidateData.designation,
      department: offer.candidateData.department,
      workLocation: offer.candidateData.work_location,
      baseSalary: offer.candidateData.base_salary,
      totalCtc: offer.candidateData.total_ctc,
      status: offer.status,
      priority: offer.metadata?.priority || 'normal',
      tags: offer.metadata?.tags || [],
      template: {
        id: offer.templateId?._id,
        name: offer.templateId?.name,
        category: offer.templateId?.category,
        industry: offer.templateId?.industry
      },
      company: {
        id: offer.companyData?.companyId?._id,
        name: offer.companyData?.companyName,
        industry: offer.companyData?.industry,
        type: offer.companyData?.companyType
      },
      generatedBy: {
        id: offer.metadata?.generatedBy?._id,
        email: offer.metadata?.generatedBy?.email,
        name: offer.metadata?.generatedBy?.name
      },
      compliance: {
        isCompliant: offer.compliance?.isCompliant || false,
        score: offer.compliance?.score || 0
      },
      tracking: {
        viewCount: offer.tracking?.viewCount || 0,
        sentAt: offer.tracking?.sentAt,
        viewedAt: offer.tracking?.viewedAt,
        expiresAt: offer.tracking?.expiresAt
      },
      createdAt: offer.createdAt,
      updatedAt: offer.updatedAt
    }));
  }

  /**
   * Get applied filters summary
   */
  getAppliedFilters(filters) {
    const applied = {};

    Object.entries(filters).forEach(([key, value]) => {
      if (value && value !== 'all' && value !== '' && 
          !(Array.isArray(value) && value.length === 0)) {
        applied[key] = value;
      }
    });

    return applied;
  }

  /**
   * Get search suggestions
   */
  async getSearchSuggestions(query, organisationId, limit = 10) {
    try {
      if (!query || query.trim().length < 2) {
        return [];
      }

      const searchRegex = { $regex: query.trim(), $options: 'i' };
      
      const suggestions = await GeneratedOffer.aggregate([
        {
          $match: {
            'metadata.organisation': organisationId,
            $or: [
              { 'candidateData.candidate_name': searchRegex },
              { 'candidateData.designation': searchRegex },
              { 'candidateData.department': searchRegex }
            ]
          }
        },
        {
          $group: {
            _id: null,
            candidates: { $addToSet: '$candidateData.candidate_name' },
            designations: { $addToSet: '$candidateData.designation' },
            departments: { $addToSet: '$candidateData.department' }
          }
        },
        {
          $project: {
            suggestions: {
              $slice: [
                {
                  $concatArrays: [
                    '$candidates',
                    '$designations',
                    '$departments'
                  ]
                },
                limit
              ]
            }
          }
        }
      ]);

      return suggestions[0]?.suggestions || [];

    } catch (error) {
      console.error('‚ùå [SearchService] Error getting suggestions:', error);
      return [];
    }
  }

  /**
   * Get search analytics
   */
  async getSearchAnalytics(organisationId, dateRange = null) {
    try {
      const matchQuery = { 'metadata.organisation': organisationId };
      
      if (dateRange) {
        matchQuery.createdAt = {
          $gte: new Date(dateRange.startDate),
          $lte: new Date(dateRange.endDate)
        };
      }

      const analytics = await GeneratedOffer.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: null,
            totalOffers: { $sum: 1 },
            totalCandidates: { $addToSet: '$candidateData.candidate_email' },
            avgSalary: { $avg: '$candidateData.total_ctc' },
            statusDistribution: {
              $push: '$status'
            },
            industryDistribution: {
              $push: '$companyData.industry'
            },
            departmentDistribution: {
              $push: '$candidateData.department'
            }
          }
        },
        {
          $project: {
            totalOffers: 1,
            uniqueCandidates: { $size: '$totalCandidates' },
            avgSalary: { $round: ['$avgSalary', 2] },
            statusBreakdown: {
              $reduce: {
                input: '$statusDistribution',
                initialValue: {},
                in: {
                  $mergeObjects: [
                    '$$value',
                    {
                      $literal: {
                        $concat: ['$$this', ': ', { $toString: { $size: { $filter: { input: '$statusDistribution', cond: { $eq: ['$$this', '$$this'] } } } } }]
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      ]);

      return analytics[0] || {};

    } catch (error) {
      console.error('‚ùå [SearchService] Error getting analytics:', error);
      return {};
    }
  }

  /**
   * Get filter options for search
   */
  async getFilterOptions(organisationId) {
    try {
      const filterOptions = await GeneratedOffer.aggregate([
        { $match: { 'metadata.organisation': organisationId } },
        {
          $group: {
            _id: null,
            statuses: { $addToSet: '$status' },
            industries: { $addToSet: '$companyData.industry' },
            companyTypes: { $addToSet: '$companyData.companyType' },
            departments: { $addToSet: '$candidateData.department' },
            locations: { $addToSet: '$candidateData.work_location' },
            priorities: { $addToSet: '$metadata.priority' },
            tags: { $addToSet: '$metadata.tags' }
          }
        },
        {
          $project: {
            statuses: { $filter: { input: '$statuses', cond: { $ne: ['$$this', null] } } },
            industries: { $filter: { input: '$industries', cond: { $ne: ['$$this', null] } } },
            companyTypes: { $filter: { input: '$companyTypes', cond: { $ne: ['$$this', null] } } },
            departments: { $filter: { input: '$departments', cond: { $ne: ['$$this', null] } } },
            locations: { $filter: { input: '$locations', cond: { $ne: ['$$this', null] } } },
            priorities: { $filter: { input: '$priorities', cond: { $ne: ['$$this', null] } } },
            tags: { $reduce: { input: '$tags', initialValue: [], in: { $concatArrays: ['$$value', '$$this'] } } }
          }
        }
      ]);

      return filterOptions[0] || {};

    } catch (error) {
      console.error('‚ùå [SearchService] Error getting filter options:', error);
      return {};
    }
  }

  /**
   * Save search as saved search
   */
  async saveSearch(searchParams, userId, organisationId, name) {
    try {
      // This would typically save to a SavedSearch model
      // For now, we'll return the search parameters
      return {
        name,
        searchParams,
        userId,
        organisationId,
        createdAt: new Date()
      };
    } catch (error) {
      console.error('‚ùå [SearchService] Error saving search:', error);
      throw error;
    }
  }
}

module.exports = new SearchService();
